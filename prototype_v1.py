# prototype_v1.py

import asyncio
import subprocess
import logging
import os
import platform
import shutil # For file copy verification potentially
from src.adapters.groq_adapter import GroqAdapter
from groq import GroqError
from pydantic import ValidationError
import json

# --- Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
# Reduce httpx noise if desired
logging.getLogger("httpx").setLevel(logging.WARNING)


# --- Model Selection ---
JUNIOR_MODEL = "meta-llama/llama-4-maverick-17b-128e-instruct"
SENIOR_MODEL = "deepseek-r1-distill-qwen-32b"

# --- Environment Setup ---
# Ensure docs directory exists (only needs to happen once)
os.makedirs("docs", exist_ok=True)
compatibility_notes_path = "docs/command_compatibility_notes.md"
if not os.path.exists(compatibility_notes_path):
    logging.warning(f"{compatibility_notes_path} not found. Creating an empty file.")
    with open(compatibility_notes_path, "w") as f:
        f.write("# Command Compatibility & Issue Notes\n\n---\n\n## macOS/BSD `sed -i`\n* Correct: `sed -i '' 's/old/new/g' filename`\n")


# --- Agent Functions ---
# junior_propose_plan, senior_review_plan, execute_command remain unchanged
# (Keep the functions from the previous version)
async def junior_propose_plan(adapter: GroqAdapter, task_description: str, context: str) -> str:
    """
    Junior agent proposes a single bash command to accomplish the task.
    """
    logging.info(f"Junior Agent ({JUNIOR_MODEL}) starting task: {task_description}")
    system_prompt = """
You are a Junior Developer Agent. Your task is to take a user request and context,
then generate ONLY the single, precise **macOS/BSD compatible** bash command
needed to accomplish the task. Do NOT add any explanation, introductory text,
or markdown formatting like ```bash ... ```. Just output the raw command.
Pay close attention to macOS/BSD compatibility, for example, macOS requires
`sed -i ''` for in-place edits without backups.
"""
    user_prompt = f"""
Task: {task_description}

Context:
{context}

Based on the task and context, provide the single macOS/BSD compatible bash command:
"""
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt},
    ]
    try:
        logging.info(f"Junior agent calling Groq API with model: {JUNIOR_MODEL}")
        response_gen = await adapter.chat_completion(
            model=JUNIOR_MODEL,
            messages=messages,
            temperature=0.1,
            max_tokens=2500,
            top_p=1,
            stop=None,
            stream=False,
        )
        if response_gen and response_gen.choices and response_gen.choices[0].message and response_gen.choices[0].message.content:
            proposed_command = response_gen.choices[0].message.content.strip()
            if proposed_command.startswith("```bash"):
                proposed_command = proposed_command.replace("```bash", "").replace("```", "").strip()
            elif proposed_command.startswith("`") and proposed_command.endswith("`"):
                 proposed_command = proposed_command[1:-1]
            logging.info(f"Junior Agent proposed command: '{proposed_command}'")
            return proposed_command
        else:
            logging.error("Junior Agent received an empty or invalid response content.")
            return "ERROR: No command generated."
    except GroqError as e:
        logging.error(f"Junior Agent failed due to Groq API error: {e}")
        return f"ERROR: API call failed - {e}"
    except (ValueError, ValidationError, json.JSONDecodeError) as e:
         logging.error(f"Junior Agent failed due to data error: {e}")
         return f"ERROR: Data validation/processing error - {e}"
    except Exception as e:
        logging.error(f"An unexpected error occurred in Junior Agent: {e}", exc_info=True)
        return f"ERROR: Unexpected error - {e}"

async def senior_review_plan(adapter: GroqAdapter, task_description: str, proposed_command: str, context: str) -> bool:
    """
    Senior agent reviews the proposed command for correctness, safety, and relevance.
    Uses reasoning_format='hidden' for the Deepseek model.
    """
    logging.info(f"Senior Agent ({SENIOR_MODEL}) reviewing command: '{proposed_command}'")

    if proposed_command.startswith("ERROR:") or not proposed_command:
        logging.warning("Senior Agent automatically REJECTING due to upstream error or empty command.")
        return False

    combined_prompt = f"""
You are a Senior Developer Agent. Your role is to review a proposed bash command
generated by a Junior Agent. Evaluate the command based on the original task
and context. Your review criteria are:
1. Technical Correctness: Is the command syntax valid?
2. Safety: Is the command likely to cause unintended data loss or system harm?
   (e.g., risky `rm` commands, incorrect redirection). Avoid potentially dangerous commands unless explicitly safe for the context.
3. Relevance: Does the command directly address the task description?
4. macOS/BSD Compatibility: Is the command compatible with standard macOS/BSD shell environments?
   (e.g., Does it correctly use `sed -i ''` for in-place edits if required?)

Original Task: {task_description}

Context:
{context}

Proposed Bash Command:
`{proposed_command}`

Review Checklist:
1. Technically Correct?
2. Safe to execute?
3. Relevant to task?
4. macOS/BSD Compatible (e.g., `sed -i ''` if needed)?

Respond with ONLY "APPROVE" or "REJECT". Do not add explanations or any other text.
Decision (APPROVE or REJECT):
"""
    messages = [
        {"role": "user", "content": combined_prompt},
    ]
    try:
        logging.info(f"Senior agent calling Groq API with model: {SENIOR_MODEL}, reasoning_format='hidden'")
        response = await adapter.chat_completion(
            model=SENIOR_MODEL,
            messages=messages,
            temperature=0.2,
            max_tokens=3000, # Increased headroom
            top_p=1,
            stop=None,
            stream=False,
            reasoning_format='hidden'
        )
        if response and response.choices and response.choices[0].message and response.choices[0].message.content:
            decision = response.choices[0].message.content.strip().upper()
            logging.info(f"Senior Agent raw decision received: '{decision}'")
            if decision == "APPROVE":
                logging.info("Senior Agent decision: APPROVE")
                return True
            elif decision == "REJECT":
                 logging.info("Senior Agent decision: REJECT")
                 return False
            else:
                 logging.warning(f"Senior Agent gave ambiguous response despite reasoning_format='hidden': '{decision}'. Defaulting to REJECT.")
                 return False
        else:
            logging.error("Senior Agent received an empty or invalid response content.")
            return False
    except GroqError as e:
        logging.error(f"Senior Agent failed due to Groq API error: {e}")
        return False
    except (ValueError, ValidationError, json.JSONDecodeError) as e:
         logging.error(f"Senior Agent failed due to data error: {e}")
         return False
    except Exception as e:
        logging.error(f"An unexpected error occurred in Senior Agent: {e}", exc_info=True)
        return False

def execute_command(command: str) -> tuple[bool, str, str]:
    """
    Executes the approved command in the shell.
    Returns (success_status, stdout, stderr).
    """
    if not command or command.startswith("ERROR:"):
        logging.error(f"Skipping execution due to invalid command: '{command}'")
        return False, "", "Invalid command provided"
    logging.info(f"Executing command: '{command}'")
    try:
        process = subprocess.run(
            command, shell=True, check=False, stdout=subprocess.PIPE,
            stderr=subprocess.PIPE, text=True, timeout=30 # Added timeout
        )
        stdout = process.stdout.strip() if process.stdout else ""
        stderr = process.stderr.strip() if process.stderr else ""
        if process.returncode == 0:
            logging.info(f"Command executed successfully. stdout:\n{stdout}")
            return True, stdout, stderr
        else:
            logging.error(f"Command failed with exit code {process.returncode}. stderr:\n{stderr}")
            return False, stdout, stderr
    except FileNotFoundError:
        err_msg = f"Error: Command not found. Make sure '{command.split()[0]}' is installed and in your PATH."
        logging.error(err_msg)
        return False, "", err_msg
    except subprocess.TimeoutExpired:
        logging.error(f"Command '{command}' timed out.")
        return False, "", "Command timed out"
    except Exception as e:
        err_msg = f"An unexpected error occurred during command execution: {e}"
        logging.error(err_msg)
        return False, "", err_msg

# --- Test Case Definitions ---

# Test Case 1: sed (Original Test)
task_sed = "In the file 'test_file_sed.txt', replace all occurrences of the word 'hello' with 'goodbye'."
async def setup_sed():
    filename = "test_file_sed.txt"
    logging.info(f"Setup for SED: Creating {filename}")
    try:
        if os.path.exists(filename): os.remove(filename) # Clean up previous run
        with open(filename, "w") as f:
            f.write("hello world\n")
            f.write("another hello line\n")
            f.write("hello again\n")
        content = open(filename).read()
        logging.info(f"Content of {filename} before execution:\n{content.strip()}")
        return f"Current directory contains '{filename}' with multiple lines containing 'hello'."
    except IOError as e:
        logging.error(f"Setup for SED failed: {e}")
        return f"ERROR: Failed to set up {filename}"
async def verify_sed(success: bool, stdout: str, stderr: str) -> bool:
    filename = "test_file_sed.txt"
    logging.info(f"Verifying SED on {filename}")
    if not success:
        logging.error("SED verification failed: Command execution failed.")
        return False
    try:
        content = open(filename).read()
        logging.info(f"Content of {filename} AFTER execution:\n{content.strip()}")
        if "goodbye" in content and "hello" not in content:
            logging.info("SED verification PASSED.")
            return True
        else:
            logging.warning("SED verification WARNING: File content mismatch.")
            return False
    except IOError as e:
        logging.error(f"SED verification failed: Cannot read {filename}. Error: {e}")
        return False
    finally:
         # Cleanup
        try:
            if os.path.exists(filename):
                os.remove(filename)
                logging.info(f"Cleaned up {filename}")
        except OSError as e:
            logging.error(f"Cleanup failed for {filename}: {e}")


# Test Case 2: touch
task_touch = "Create an empty file named 'new_empty_file.txt'."
async def setup_touch():
    filename = "new_empty_file.txt"
    logging.info(f"Setup for TOUCH: Ensuring {filename} does not exist.")
    try:
        if os.path.exists(filename): os.remove(filename)
        return "Current directory is empty. Create the file 'new_empty_file.txt'."
    except OSError as e:
        logging.error(f"Setup for TOUCH failed: {e}")
        return f"ERROR: Failed to clean up {filename}"
async def verify_touch(success: bool, stdout: str, stderr: str) -> bool:
    filename = "new_empty_file.txt"
    logging.info(f"Verifying TOUCH for {filename}")
    passed = False
    if not success:
        logging.error("TOUCH verification failed: Command execution failed.")
    elif not os.path.exists(filename):
        logging.error(f"TOUCH verification failed: {filename} does not exist.")
    elif os.path.getsize(filename) != 0:
        logging.warning(f"TOUCH verification WARNING: {filename} is not empty.")
        # Still consider it a pass for existence, but log warning
        passed = True
    else:
        logging.info(f"TOUCH verification PASSED: {filename} exists and is empty.")
        passed = True
    # Cleanup
    try:
        if os.path.exists(filename):
            os.remove(filename)
            logging.info(f"Cleaned up {filename}")
    except OSError as e:
        logging.error(f"Cleanup failed for {filename}: {e}")
    return passed

# Test Case 3: cp
task_cp = "Create a copy of 'source_file_cp.txt' named 'copy_file_cp.txt'."
async def setup_cp():
    source = "source_file_cp.txt"
    copy = "copy_file_cp.txt"
    logging.info(f"Setup for CP: Creating {source}, ensuring {copy} does not exist.")
    try:
        if os.path.exists(source): os.remove(source)
        if os.path.exists(copy): os.remove(copy)
        content_to_write = "This is the source file.\nIt has two lines.\n"
        with open(source, "w") as f:
            f.write(content_to_write)
        return f"Current directory contains '{source}' with content:\n```\n{content_to_write}```\nCopy it to '{copy}'."
    except OSError as e:
        logging.error(f"Setup for CP failed: {e}")
        return f"ERROR: Failed to set up files for CP test."
async def verify_cp(success: bool, stdout: str, stderr: str) -> bool:
    source = "source_file_cp.txt"
    copy = "copy_file_cp.txt"
    logging.info(f"Verifying CP from {source} to {copy}")
    passed = False
    if not success:
        logging.error("CP verification failed: Command execution failed.")
    elif not os.path.exists(copy):
        logging.error(f"CP verification failed: {copy} does not exist.")
    else:
        try:
            source_content = open(source).read()
            copy_content = open(copy).read()
            if source_content == copy_content:
                logging.info(f"CP verification PASSED: {copy} exists and content matches {source}.")
                passed = True
            else:
                logging.error(f"CP verification failed: Content of {copy} does not match {source}.")
        except IOError as e:
            logging.error(f"CP verification failed: Error reading files. {e}")
    # Cleanup
    try:
        if os.path.exists(source): os.remove(source)
        if os.path.exists(copy): os.remove(copy)
        logging.info(f"Cleaned up {source} and {copy}")
    except OSError as e:
        logging.error(f"Cleanup failed for CP files: {e}")
    return passed

# Test Case 4: mkdir
task_mkdir = "Create a new directory named 'new_test_dir'."
async def setup_mkdir():
    dirname = "new_test_dir"
    logging.info(f"Setup for MKDIR: Ensuring {dirname} does not exist.")
    try:
        if os.path.exists(dirname): shutil.rmtree(dirname) # Remove dir and contents if exists
        return "Current directory is ready. Create the directory 'new_test_dir'."
    except OSError as e:
        logging.error(f"Setup for MKDIR failed: {e}")
        return f"ERROR: Failed to clean up {dirname}"
async def verify_mkdir(success: bool, stdout: str, stderr: str) -> bool:
    dirname = "new_test_dir"
    logging.info(f"Verifying MKDIR for {dirname}")
    passed = False
    if not success:
        logging.error("MKDIR verification failed: Command execution failed.")
    elif not os.path.exists(dirname):
        logging.error(f"MKDIR verification failed: {dirname} does not exist.")
    elif not os.path.isdir(dirname):
        logging.error(f"MKDIR verification failed: {dirname} exists but is not a directory.")
    else:
        logging.info(f"MKDIR verification PASSED: {dirname} exists and is a directory.")
        passed = True
    # Cleanup
    try:
        if os.path.exists(dirname):
            os.rmdir(dirname) # Use rmdir as it should be empty
            logging.info(f"Cleaned up {dirname}")
    except OSError as e:
        # If it failed, maybe the agent put something inside? Log warning.
        logging.warning(f"Cleanup using rmdir failed for {dirname} (maybe not empty?): {e}")
        try: # Attempt removal with shutil.rmtree as fallback
             if os.path.exists(dirname):
                  shutil.rmtree(dirname)
                  logging.info(f"Cleaned up {dirname} using shutil.rmtree.")
        except OSError as e2:
             logging.error(f"Force cleanup failed for {dirname}: {e2}")
    return passed

# Test Case 5: grep
task_grep = "Find lines containing the word 'unique_pattern' in the file 'grep_test_file.txt'."
async def setup_grep():
    filename = "grep_test_file.txt"
    logging.info(f"Setup for GREP: Creating {filename}")
    try:
        if os.path.exists(filename): os.remove(filename)
        content_to_write = "Line one.\nLine with unique_pattern here.\nLine three.\nAnother unique_pattern line.\n"
        with open(filename, "w") as f:
            f.write(content_to_write)
        return f"File '{filename}' exists with content:\n```\n{content_to_write}```\nFind lines containing 'unique_pattern'."
    except OSError as e:
        logging.error(f"Setup for GREP failed: {e}")
        return f"ERROR: Failed to set up {filename}"
async def verify_grep(success: bool, stdout: str, stderr: str) -> bool:
    filename = "grep_test_file.txt"
    logging.info(f"Verifying GREP for 'unique_pattern' in {filename}")
    passed = False
    # Grep returns non-zero exit code (success=False) if pattern not found, which is valid execution.
    # We verify based on stdout content.
    if "unique_pattern" in stdout and stdout.count('\n') == 1 : # Expecting 2 lines found -> 1 newline in stripped stdout
        logging.info(f"GREP verification PASSED. Found expected pattern in stdout:\n{stdout}")
        passed = True
    elif not stdout and not success : # If grep finds nothing, success is False and stdout is empty
         logging.warning(f"GREP verification WARNING: Command ran but found nothing (stdout empty, exit code != 0). This might be okay depending on exact grep command used.")
         # Consider this a pass *if* the command was valid grep, but pattern wasn't there
         # For this specific test, we expect matches, so it's a fail.
         passed = False
    else:
        logging.error(f"GREP verification FAILED. Stdout mismatch or unexpected error. Success={success}, Stdout:\n{stdout}")
        passed = False
     # Cleanup
    try:
        if os.path.exists(filename):
            os.remove(filename)
            logging.info(f"Cleaned up {filename}")
    except OSError as e:
        logging.error(f"Cleanup failed for {filename}: {e}")
    return passed


# Test Case 6: ls
task_ls = "List the files in the current directory in long format, including hidden files."
async def setup_ls():
    filename = ".hidden_test_file_ls.txt" # Create a hidden file
    dirname = "test_dir_ls" # Create a directory
    logging.info(f"Setup for LS: Creating '{filename}' and '{dirname}'.")
    try:
        if os.path.exists(filename): os.remove(filename)
        if os.path.exists(dirname): shutil.rmtree(dirname)
        with open(filename, "w") as f: f.write("hidden")
        os.mkdir(dirname)
        return f"Current directory contains a hidden file '{filename}' and a directory '{dirname}'. List them in long format."
    except OSError as e:
        logging.error(f"Setup for LS failed: {e}")
        return f"ERROR: Failed to set up files for LS test."
async def verify_ls(success: bool, stdout: str, stderr: str) -> bool:
    filename = ".hidden_test_file_ls.txt"
    dirname = "test_dir_ls"
    logging.info(f"Verifying LS")
    passed = False
    if not success:
        logging.error("LS verification failed: Command execution failed.")
    # Check if both the hidden file and the directory appear in the output
    elif filename in stdout and dirname in stdout:
        logging.info(f"LS verification PASSED. Found '{filename}' and '{dirname}' in stdout:\n{stdout}")
        passed = True
    else:
        logging.error(f"LS verification FAILED. Expected files not found in stdout:\n{stdout}")
    # Cleanup
    try:
        if os.path.exists(filename): os.remove(filename)
        if os.path.exists(dirname): shutil.rmtree(dirname)
        logging.info(f"Cleaned up {filename} and {dirname}")
    except OSError as e:
        logging.error(f"Cleanup failed for LS files: {e}")
    return passed


# --- Test Runner ---
async def run_test_case(
    adapter: GroqAdapter,
    test_name: str,
    task_description: str,
    setup_func: callable,
    verify_func: callable
):
    """Runs a single test case using the agent workflow."""
    logging.info(f"--- Starting Test Case: {test_name} ---")
    separator = "=" * 60

    # 1. Setup
    logging.info(f"Running setup for {test_name}...")
    initial_context = await setup_func()
    if initial_context.startswith("ERROR:"):
        logging.error(f"Test Case {test_name} SKIPPED due to setup failure.")
        print(f"\n{separator}\nTest Case: {test_name} -> SKIP (Setup Failed)\n{separator}\n")
        return False # Indicate test skip/failure

    # 2. Junior Propose
    proposed_command = await junior_propose_plan(adapter, task_description, initial_context)
    if proposed_command.startswith("ERROR:"):
        logging.error(f"Test Case {test_name} FAILED: Junior agent failed to propose command.")
        print(f"\n{separator}\nTest Case: {test_name} -> FAIL (Junior Proposal)\n{separator}\n")
        # Try to run verify func anyway for cleanup, passing failure state
        await verify_func(False, "", proposed_command)
        return False

    # 3. Senior Review
    is_approved = await senior_review_plan(adapter, task_description, proposed_command, initial_context)
    if not is_approved:
        logging.warning(f"Test Case {test_name} STOPPED: Plan REJECTED by Senior Agent.")
        print(f"\n{separator}\nTest Case: {test_name} -> STOP (Senior Rejected)\n{separator}\n")
         # Try to run verify func anyway for cleanup, passing rejection state
        await verify_func(False, "", "Senior rejected")
        return False # Consider rejection a non-pass for this positive test flow

    # 4. Execute
    logging.info("Plan approved. Executing command...")
    success, stdout, stderr = execute_command(proposed_command)

    # 5. Verify
    logging.info(f"Running verification for {test_name}...")
    passed = await verify_func(success, stdout, stderr)

    result_str = "PASS" if passed else "FAIL"
    logging.info(f"--- Test Case: {test_name} Result: {result_str} ---")
    print(f"\n{separator}\nTest Case: {test_name} -> {result_str}\n{separator}\n")
    return passed


async def main():
    """
    Main execution flow - initializes adapter and runs test cases.
    """
    logging.info("--- Initializing Prototype V1 Test Suite ---")
    try:
        groq_adapter = GroqAdapter()
        logging.info("Groq Adapter initialized.")
    except ValueError as e:
         logging.error(f"Failed to initialize Groq Adapter: {e}")
         return
    except Exception as e:
        logging.error(f"An unexpected error occurred during adapter initialization: {e}", exc_info=True)
        return

    # List of test cases to run
    test_cases = [
        {"name": "SED Replace", "task": task_sed, "setup": setup_sed, "verify": verify_sed},
        {"name": "TOUCH Create", "task": task_touch, "setup": setup_touch, "verify": verify_touch},
        {"name": "CP Copy", "task": task_cp, "setup": setup_cp, "verify": verify_cp},
        {"name": "MKDIR Create", "task": task_mkdir, "setup": setup_mkdir, "verify": verify_mkdir},
        {"name": "GREP Find", "task": task_grep, "setup": setup_grep, "verify": verify_grep},
        {"name": "LS List", "task": task_ls, "setup": setup_ls, "verify": verify_ls},
    ]

    results = {}
    for test in test_cases:
        passed = await run_test_case(
            adapter=groq_adapter,
            test_name=test["name"],
            task_description=test["task"],
            setup_func=test["setup"],
            verify_func=test["verify"]
        )
        results[test["name"]] = "PASS" if passed else "FAIL/SKIP/REJECT" # Store simple result

    logging.info("--- Prototype V1 Test Suite Finished ---")
    print("\n===== Test Suite Summary =====")
    for name, result in results.items():
        print(f"{name}: {result}")
    print("==============================")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logging.critical(f"Unhandled exception in main loop: {e}", exc_info=True)