# src/operations/command_execution.py
import subprocess
import logging
from typing import Tuple

def execute_command(command: str) -> Tuple[bool, str, str]:
    """
    Executes a shell command and returns its success status, stdout, and stderr.

    Args:
        command: The command string to execute.

    Returns:
        A tuple containing:
            - bool: True if the command executed successfully (return code 0), False otherwise.
            - str: The standard output of the command.
            - str: The standard error of the command.
    """
    if not command or command.startswith("ERROR:"):
        logging.error(f"Skipping execution of invalid/erroneous command: '{command}'")
        return False, "", "Invalid command provided."

    logging.info(f"Executing command: '{command}'")
    try:
        # Using shell=True can be a security risk if the command is constructed from untrusted input.
        # Ensure commands are properly sanitized or generated by trusted sources.
        process = subprocess.run(
            command, shell=True, check=False, stdout=subprocess.PIPE,
            stderr=subprocess.PIPE, text=True, timeout=30 # 30-second timeout
        )
        stdout = process.stdout.strip() if process.stdout else ""
        stderr = process.stderr.strip() if process.stderr else ""

        if process.returncode == 0:
            logging.info(f"Command executed successfully. stdout:\n{stdout}")
            return True, stdout, stderr
        else:
            logging.warning(f"Command failed with return code {process.returncode}. stderr:\n{stderr}")
            return False, stdout, stderr
    except FileNotFoundError:
        err_msg = f"Command not found: {command.split()[0]}"
        logging.error(err_msg)
        return False, "", err_msg
    except subprocess.TimeoutExpired:
        err_msg = f"Command timed out after 30 seconds: '{command}'"
        logging.error(err_msg)
        return False, "", err_msg
    except Exception as e:
        err_msg = f"An unexpected error occurred during command execution: {e}"
        logging.error(err_msg, exc_info=True) # Include stack trace for unexpected errors
        return False, "", err_msg
